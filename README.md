3д Модель разработана в программе fusion 360. Модель полность отражает дейстельный вид ключевых узлов робота (отсутствуют тумблеры, дисплей, энкодер, гироскоп, контролер дриблера, обводной ролик, датчики линий). 3 основых слоя вырезаны на лазерном станке из фанеры толщиной 4 мм.

![изображение](https://github.com/user-attachments/assets/b7bae456-a14d-4c49-bbff-046d32e7cd6a)

Плата разведена в программе EasyEDA, изготовлена на заводе PCBWay. Основной микроконтроллер - ESP32 30 pin. Используемые периферийные модули:
•	Гироскоп + акселерометр – MPU6050 (I2C)
•	Инфракрасный локатор – IR Locator 360 (I2C)
•	Дисплей – OLED 128x64 (I2C)
•	Камера – OpenMV H7, M7 (UART)
•	16 оптопар (красный светодиод + фототранзистор) -> Аналоговый мультиплексор CD74HC4067
•	4 мотора JGA25-370, Polulu -> 2 драйвера моторов DRV8833
•	Бесколлекторный мотор 2750KV -> Контроллер ESC 30A

Питание 2-мя литий-ионными аккумуляторами формата 18650, соединенных последовательно. Основная плата питается через понижающий модуль до 5В, приводы и бесколлекторный мотор  питаются напрямую. Конденсатор соленоіда заряжается до напряжения 48 вольт повышающим модулем XL6019, при поступлении сигнала от микроконтроллера происходит разрядка кондесатора на катушку соленоида. 
Для создания омниплатформы мы использовали самодельные омниколеса, напечатанные на 3Д-принтере. В качестве роликов использовались печатные диски, на которые были надеты сантехнические уплотнительные кольца O-ring.

Камера:

![изображение](https://github.com/user-attachments/assets/3be9d039-7282-4c1f-ac09-2bc57ba9b08b)

Для обеспечения угла обзора камеры в 360 градусов, на токарном станке с ЧПУ было изготовлено зеркало конической формы с углом образующей в 30 градусов. Для размещение зеркала над камерой был куплен стаканчик от детского питания и распечатан на 3Д-принтере фиксаторы стакана. Фиксаторы позволяют в небольшом диапазоне (5 мм) сдвигать ось зеркала относительно оси камеры, тем самым центрируя его. Крепление зеркала при помощи 4 шпилек позволяет допиваться параллельности плоскостей зеркала и камеры + регулировать его высоту. 
Дрибблер:

![изображение](https://github.com/user-attachments/assets/f3c605be-4195-48f1-ad9b-971095923e07)

Для контроля мяча наша команда спроектировала и изготовила дрибблер. В основе лежит бесколлекторный мотор, описанный выше. 
Ролики сделаны из силикона, залитого на распечатанный диск, радиальные розовые стенки выполняют две функции: передача вращательного момента с диска на силиконовую покрышку и сдерживание центробежного расширения покрышки. 

![изображение](https://github.com/user-attachments/assets/6e41bad5-a976-46e2-8a64-ca3749965575)

Диск фиксируется на латунном вале при помощи винтика М3 (резьба нарезана в вале). Вал приводится во вращение кольцевым ремнем GT-2. Для натяжки ремня используется натяжной ролик, сделанный из двух подшипников. 
Дрибблер имеет одну степень свободы относительно оси установки. Также дрибблер подпружинен (пружины крепятся к верхней платформе) для создания дополнительного давления на мяч, следовательно увеличивается сила трения мяча об поле. Пружины не позволяют дрибблеру сильно наклоняться вперед.  

Датчики определения линии:

![изображение](https://github.com/user-attachments/assets/cdd0b451-6ec4-4cbf-b873-959b3bd4a6f4)

Датчики линии представляют собой оптопары из красного светодиода и фототранзистора, подключенных навесным монтажом. Из-за этого фототранзисторы не до конца утоплены в свои посадочные места, в следствии чего при близком расположении мяча фототранзисторы засвечивались им, для решения этой проблемы был сделан бортик из картона, потому что этот материал легкий и плотный. 

На поле играют 2 робота. Один из них выполняет функцию нападающего, другой – защитника.
Чтобы ускорить разработку логики роботов и сделать ее независимой от разработки аппаратной части, был создан симулятор на движке Unity.

![изображение](https://github.com/user-attachments/assets/a76cc169-748d-4114-8975-e2160d73e9ab)

Он позволяет создавать модели роботов, быстро подключать и убирать устройства (отдельные компоненты MonoBehaviour для моторов, мультиплексора линий, камер двух моделей – TrackingCam, закрепленная горизонтально, и OpenMV с омнизеркалом, локатора ИК-излучения и т.д.), имитировать условия игры, а также обеспечивает быструю и удобную отладку. Для большей реалистичности каждый датчик имеет настраиваемые случайные погрешности и минимальное время обновления значения. Благодаря симулятору получилось разработать игровую логику роботов ещё до завершения аппаратной части. При этом симулятор обладает высокой реалистичностью, на нем получилось обнаружить много реальных багов.
Детектирование линий.
Предварительно датчики калибруются: сохраняется значение яркости для зеленого и белого цветов. Перед использованием проходим по всем датчикам линий: если яркость больше порогового значения между зеленым и белым, датчик видит линию. Сохраняем в массиве время из millis(), когда в последний раз он видел линию.
Для определения единичного вектора и угла до линии проходим по всем датчикам, и если датчик видел линию в последние X миллисекунд (Х регулируется), то прибавляем вектор А в направлении этого датчика к результирующему вектору Б. Модуль вектора А тем больше, чем раньше мы в последний раз видели линию на этом датчике (на случай, если робот по инерции выскакивает за линию, чтобы он мог в течение X миллисекунд вернуться назад, даже если линия теперь с другой стороны от него).
Во время тестов мы обнаружили, что если поднести мяч к роботу вплотную, то датчики начинают воспринимать его излучение как линию. Это привело к необычным последствиям: нападающий во время дриблинга не ехал вперед, а защитник, наоборот, когда видел мяч перед собой в выемке, начинал толкать его вперед, что может быть неплохой тактикой в игре, однако специально такой логики прописано не было.
Логика защитника.
Защитник удерживается на линии у штрафной зоны и перемещается по ней за мячом в определенных границах. При этом учитывается много краевых случаев.
Каждому датчику присваивается приоритет. По очереди проходим по всем датчикам линий, для обеих левой и правой сторон робота суммируем те, которые над линией, и вычитаем те, которые ниже. Так определяем, вверх или вниз нужно переместить каждую половину робота для удержания на линии. Для балансировки используются PID-регуляторы.
Если линию не видно, то робот разворачивается спиной к своим воротам (по гироскопу) и едет назад, объезжая мяч, если тот находится сзади.
Перемещение к мячу по горизонтали обеспечивает PID-регулятор по углу до мяча. При этом при поворотах горизонтальная скорость уменьшается, чтобы защитник не слетал с линии.

![изображение](https://github.com/user-attachments/assets/863cab86-1db0-45d1-842f-efb1d813a7d9)
 
Определение захвата мяча
У нападающего используется плата захвата мяча, которая содержит два ИК-датчика и возвращает 1, если оба видят мяч вблизи. Однако датчики чувствительные и даже при вращении мяча могут считать, что он пропал. Поэтому используется алгоритм, считающий мяч захваченным, если в последние 200 мс датчики послали хотя бы одну 1.

![изображение](https://github.com/user-attachments/assets/e7b53674-73e2-48be-9d97-5a5858543b67)

Мяч виден только дальнему датчику, поскольку обзор датчиков на внешнюю сторону для них заблокирован колпачком.

![изображение](https://github.com/user-attachments/assets/cd5655d1-1445-4055-9b18-93de6507f344)

 
Движение робота
В программе прописано несколько функций, которые отвечают за движение робота и позволяют:
	Задавать скорость отдельным моторам напрямую (от -100 до 100)
	Ехать в определённом направлении с заданной скоростью поступательного и вращательного движений. На фото на 2 мотора подается скорость Vx=V*cos(45-a), а на остальные Vy=V*cos(45+a). Скорость вращения добавляется на все моторы в одном направлении.

  ![изображение](https://github.com/user-attachments/assets/9efde396-664a-4f20-8c15-0db616a48b43)
 

 
Ехать с определённой скоростью по локальным осям X, Y и с вращением.
![изображение](https://github.com/user-attachments/assets/c8977147-d958-4786-989b-b5fb4cbd4768)

Решаем систему уравнений с учетом того, что скорости 1 и 3, 2 и 4 моторов равны; вращение аналогично пункту выше.
Скорости всех моторов имеют такое положительное направление, при котором у всех моторов робот едет вперед.

 ![изображение](https://github.com/user-attachments/assets/446f1f07-a859-440f-829d-0a1bacc22158)




